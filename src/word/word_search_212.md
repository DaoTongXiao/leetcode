**逐层深入、掰开揉碎地讲解**这个“单词搜索 II”问题（LeetCode 212），包括：

- 为什么暴力不行？
- Trie 是什么？为什么用它？
- DFS 回溯怎么配合 Trie？
- 代码每一步在做什么？
- 剪枝和优化细节
- 举个完整例子走一遍流程

---

# 🌟 一、问题再理解

你有一个二维字符网格 `board`，比如：

```
[
  ['o','a','a','n'],
  ['e','t','a','e'],
  ['i','h','k','r'],
  ['i','f','l','v']
]
```

和一个单词列表 `words = ["oath","pea","eat","rain"]`

你要找出：**哪些单词可以通过在网格中“走相邻格子”拼出来，且每个格子只能用一次。**

✅ 输出：`["eat","oath"]`

---

# 🚫 二、为什么不能暴力？—— 时间爆炸！

暴力思路：对每个单词，在 board 上做一次 DFS（像 Word Search I）。

- 假设有 `W` 个单词，每个单词平均长度 `L`
- 网格大小 `M x N`
- 每个起点最多走 `4^L` 条路径（指数爆炸！）

→ 总时间复杂度 ≈ `O(W * M * N * 4^L)`

当 `W=1000`, `M=N=10`, `L=10` → 1000 * 100 * 4^10 ≈ **1000 * 100 * 1,000,000 = 1000亿次操作！**

💥 肯定超时！

---

# ✅ 三、Trie 是什么？为什么要用？

## 什么是 Trie（字典树 / 前缀树）？

Trie 是一种树形结构，用于高效存储和查找字符串集合。

比如单词：`["eat", "eats", "sea", "see"]`

构建 Trie：

```
        root
       /    \
      e      s
     /       / \
    a       e   e
   / \     /     \
  t   t   a       e
       \
        s
```

- 每个节点代表一个字符。
- 从根到某个节点的路径构成一个前缀。
- 如果某个节点标记了“这是一个完整单词”，比如 `node.word = "eat"`，就说明路径到此是一个有效单词。

## 为什么用 Trie？

1. **共享前缀**：比如 "eat" 和 "eats" 共享 "eat"，DFS 时走一次路径就能同时匹配两个词。
2. **提前剪枝**：如果当前路径在 Trie 中不存在（比如你拼了 "xyz"，但 Trie 里没有以 "xyz" 开头的词），直接放弃，不继续递归。
3. **批量搜索**：一次 DFS 遍历，可以匹配多个单词，而不是一个一个搜。

👉 **Trie 把“多个单词搜索”合并成“一次前缀路径探索”**，效率飞跃！

---

# 🌀 四、DFS + Trie 如何配合？

我们不是“对每个单词搜网格”，而是：

> **从网格每个位置出发，沿着相邻格子走，同时在 Trie 里“同步走”，看能拼出什么单词。**

## 举个例子：

当前在 `(0,0)`，字符是 `'o'`。

- Trie 根节点有没有 `'o'` 子节点？有 → 往下走。
- 到 `'o'` 节点，它不是完整单词（`word = None`）。
- 继续走相邻格子，比如 `(0,1)` 是 `'a'` → 拼成 `"oa"`。
- Trie 中 `'o'` 节点有没有 `'a'` 子节点？有 → 继续。
- `(1,1)` 是 `'t'` → `"oat"` → Trie 中有吗？有。
- `(1,2)` 是 `'h'` → `"oath"` → Trie 中这个节点 `word = "oath"` → ✅ 找到一个词！

同时，如果 Trie 中还有 `"oaths"`，我们会继续往下找，**一次路径匹配多个词！**

---

# 🧩 五、代码逐行详解（Python）

我们用注释一行行讲清楚：

```python
class TrieNode:
    def __init__(self):
        self.children = {}  # 子节点映射：字符 -> TrieNode
        self.word = None    # 如果是单词结尾，存储完整单词，否则 None

class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        # 1️⃣ 构建 Trie
        root = TrieNode()
        for word in words:
            node = root
            for c in word:
                if c not in node.children:
                    node.children[c] = TrieNode()  # 创建新节点
                node = node.children[c]           # 移动到子节点
            node.word = word  # 标记：从根到此节点构成 word

        m, n = len(board), len(board[0])
        res = set()  # 用 set 避免重复添加同一个单词

        # 2️⃣ DFS 回溯函数
        def dfs(i, j, node):
            # 越界 或 已访问过（用 '#' 标记）
            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] == '#':
                return

            c = board[i][j]  # 当前字符

            # Trie 中没有以当前字符开头的路径 → 剪枝！
            if c not in node.children:
                return

            # 同步移动到 Trie 的下一个节点
            node = node.children[c]

            # ✅ 如果当前节点是一个完整单词，加入结果
            if node.word:
                res.add(node.word)
                # 注意：不要 return！因为可能有更长的单词，比如 "eat" 和 "eats"

            # 3️⃣ 回溯标记：防止重复使用当前格子
            temp = board[i][j]
            board[i][j] = '#'

            # 4️⃣ 递归四个方向
            dfs(i+1, j, node)
            dfs(i-1, j, node)
            dfs(i, j+1, node)
            dfs(i, j-1, node)

            # 5️⃣ 回溯恢复
            board[i][j] = temp

        # 6️⃣ 从每个格子作为起点开始搜索
        for i in range(m):
            for j in range(n):
                dfs(i, j, root)

        return list(res)
```

---

# 🧹 六、关键细节 & 优化

## 1. 为什么用 `set()` 存结果？

同一个单词可能从不同路径被找到多次（比如 "a" 在多个位置），用 `set` 自动去重。

## 2. 为什么找到单词后不 `return`？

因为可能有更长的单词共享前缀！

比如 Trie 里有 `"eat"` 和 `"eats"`：

- 你走到 `"eat"` 时，找到了一个词，但你还得继续走，看能不能拼出 `"eats"`。

## 3. 回溯标记为什么用 `'#'`？

- 简单高效，直接修改原数组。
- 递归返回时恢复原值，不影响其他路径。

⚠️ 注意：如果题目不允许修改原数组，可以用 `visited` 二维布尔数组代替。

## 4. 【进阶】Trie 剪枝优化（可选）

当你找到一个单词后，可以“剪掉”这个分支（如果它没有子节点），避免后续无用搜索。

```python
# 在找到 word 后：
if node.word:
    res.add(node.word)
    node.word = None  # 避免重复添加
    # 可选：如果该节点没有子节点，可以通知父节点删除它（需要反向指针或递归清理）
```

更高级的“动态删除”需要维护父节点引用，面试中不强制要求。

---

# 🎯 七、完整例子走一遍

假设：

```python
board = [
  ['o','a','a','n'],
  ['e','t','a','e'],
  ['i','h','k','r'],
  ['i','f','l','v']
]
words = ["oath","pea","eat","rain"]
```

### 步骤 1：构建 Trie

插入所有单词：

```
root
├── o → a → t → h (word="oath")
├── p → e → a (word="pea")
├── e → a → t (word="eat")
└── r → a → i → n (word="rain")
```

### 步骤 2：从 (0,0) 开始，字符 'o'

- Trie 有 'o' → 进入 o 节点
- 往右到 (0,1) 'a' → "oa" → Trie 有
- 往下到 (1,1) 't' → "oat" → Trie 有
- 往右到 (1,2) 'a'？不行，要找 'h'
- 往下到 (2,1) 'h' → "oath" → ✅ 找到！加入 res

### 从 (1,0) 开始，字符 'e'

- Trie 有 'e' → 进入
- 往右 (1,1) 't' → "et" → Trie 无 → 剪枝
- 往上 (0,0) 'o' → "eo" → 无
- 往右再试 (1,1) 已试
- 往下 (2,0) 'i' → "ei" → 无
- 往左越界
- → 换方向：从 (1,0) 往右到 (1,1) 不行，试试 (1,0) → (0,0) 不行，试试 (1,0) → (1,1) 不行...

等一下！我们漏了：

从 (1,0)='e' → 往右上？不行。试试：

(1,0) → (0,0)='o' ❌  
(1,0) → (2,0)='i' ❌  
(1,0) → (1,1)='t' ❌  
(1,0) → (1,-1) 越界

→ 似乎找不到 "eat"？

别急！我们换个起点：

从 (1,0)='e' → 往右 (1,1)='t' 不行，但：

从 (1,2)='a' 开始？不，我们是从每个格子作为**起点**。

试试从 (1,0) 出发：

- 'e' → Trie 有
- 往右 (1,1)='t' → "et" ❌
- 往上 (0,0)='o' → "eo" ❌
- 往下 (2,0)='i' → "ei" ❌
- 往左 ❌

→ 换起点：从 (0,1)='a'？不行，Trie 根节点没有 'a'（除非有以 'a' 开头的词）

→ 从 (1,0) 不行，试试 (0,3)='n'？不行

→ 试试 (1,3)='e'？Trie 根节点有 'e'！

从 (1,3)='e' 开始：

- 往左 (1,2)='a' → "ea" ✅
- 往上 (0,2)='a' → "eaa" ❌
- 往左 (1,1)='t' → "eat" ✅ → 找到！

所以路径是：(1,3) → (1,2) → (1,1) = "e" → "a" → "t" = "eat"

✅ 所以最终找到 `"oath"` 和 `"eat"`

---

# 📊 八、复杂度再分析

- **构建 Trie**：`O(Σ|words[i]|)` — 所有单词总长度
- **DFS 搜索**：最坏 `O(M * N * 4^L)`，但 Trie 剪枝让实际远小于此
- **空间**：Trie 空间 `O(Σ|words[i]|)`，递归栈 `O(L)`

---

# ✅ 九、总结：解题心法口诀

> **“Trie 存词，DFS 同步走；前缀剪枝，回溯防重用；找到就收，别急着回头（可能还有更长词）！”**

---

